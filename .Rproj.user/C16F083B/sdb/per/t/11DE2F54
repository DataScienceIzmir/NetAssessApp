{
    "contents" : "library(RSQLite)  # database\nlibrary(sp)       # areaserved\nlibrary(deldir)   # areaserved\nlibrary(rgeos)    # areaserved\nlibrary(rgdal)    # areaserved\nlibrary(reshape2) # cormat\nlibrary(plotrix)  # cormat\nlibrary(ellipse)  # cormat\nlibrary(Hmisc)    # cormat\n\nsource(\"R/voronoi.R\")\nsource(\"R/agePyramid.R\")\nsource(\"R/cormatdb.R\")\n\nload(\"data/tracts.rda\")\nload(\"data/usborder.rda\")\n\n\n\noptions(stringsAsFactors = FALSE)\n\ndb <- dbConnect(SQLite(), dbname = \"data/netassess.sqlite\")\n\n# Create the list object for populating the state dropdown on the area of\n# interest floater\nstates <- unique(dbGetQuery(db, \"SELECT CODE, NAME FROM states\"))\nstate.list <- states$CODE\nnames(state.list) <- states$NAME\n\n# Create the list object for populating the CBSA dropdown on the area of\n# interest floater\ncbsa <- dbGetQuery(db, \"SELECT CODE, NAME FROM cbsas\")\ncbsa.list <- cbsa$CODE\nnames(cbsa.list) <- cbsa$NAME\n\n# Create the list object for populating the CSA dropdown on the area of interest\n# floater\ncsa <- dbGetQuery(db, \"SELECT CODE, NAME FROM csas\")\ncsa.list <- csa$CODE\nnames(csa.list) <- csa$NAME\n\nparams <- dbGetQuery(db, \"SELECT Parameter_Code, Parameter_Desc FROM params\")\nparams.list <- params$Parameter_Code\nnames(params.list) <- paste(params$Parameter_Code, params$Parameter_Desc, sep = \" - \")\nparams.list <- c(\"Choose Parameter of Interest\" = -1, params.list)\n\ncreateSites <- function() {\n  \n  jsonArray <- function(a, quote = FALSE) {\n    if(quote) {\n      op <- paste0('[\"', paste0(a, collapse = '\", \"'), '\"]')\n    } else {\n      op <- paste0(\"[\", paste0(a, collapse = \", \"), \"]\")      \n    }\n    return(op)\n  }\n  \n  jsonObject <- function(o) {\n    \n    n <- paste0('\"', names(o), '\"')\n    p <- sapply(o, function(x) {\n      if((substr(x, 1, 1) == \"[\" & substr(x, nchar(x), nchar(x)) == \"]\") |\n           (substr(x, 1, 1) == \"{\" & substr(x, nchar(x), nchar(x)) == \"}\")) {\n        op <- x\n      } else {\n        op <- paste0('\"', x, '\"')\n      }\n      return(op)\n    })\n    paste0(\"{\", paste(n, p, sep = \": \", collapse = \", \"), \"}\")\n    \n  }\n  \n  mons <- dbGetQuery(db, \"SELECT * FROM sites\")\n  latlng <- paste(mons$Latitude, mons$Longitude, sep = \"_\")\n  dup <- duplicated(latlng)\n  s <- mons[!dup, ]\n  d <- mons[dup, ]\n  sites <- sapply(seq(nrow(s)), function(r) {\n    \n    alt <- d$Latitude == s$Latitude[r] & d$Longitude == s$Longitude[r]\n    key <- s$Key[r]\n    site_id <- sprintf(\"%02i-%03i-%04i\", s$State_Code[r], s$County_Code[r], s$Site_ID[r])\n    if(sum(alt) > 0) {\n      key <- c(key, d$Key[alt])\n      site_id <- c(site_id, sprintf(\"%02i-%03i-%04i\", d$State_Code[alt], d$County_Code[alt], d$Site_ID[alt]))\n      s$Count[r] <- s$Count[r] + sum(d$Count[alt])\n      s$Crit_Count[r] <- s$Crit_Count[r] + sum(d$Crit_Count[alt])\n      s$HAP_Count[r] <- s$HAP_Count[r] + sum(d$HAP_Count[alt])\n      s$Met_Count[r] <- s$Met_Count[r] + sum(d$Met_Count[alt])\n    }\n    key <- jsonArray(key)\n    site_id <- jsonArray(site_id, TRUE)\n    \n    properties <- c(key = key, site_id = site_id, as.list(s[r, c(\"State_Code\", \"County_Code\", \"Street_Address\", \"Count\", \"Crit_Count\", \"HAP_Count\", \"Met_Count\")]))\n    properties$Street_Address <- gsub(\"'\", \"&#039;\", properties$Street_Address, fixed = TRUE)\n    properties$Street_Address <- gsub('\"', \"&quot;\", properties$Street_Address, fixed = TRUE)\n    properties <- jsonObject(properties)\n    geometry <- jsonObject(list(type = \"Point\", coordinates = jsonArray(c(s$Longitude[r], s$Latitude[r]))))\n    \n    return(jsonObject(list(type = \"Feature\", geometry = geometry, properties = properties)))\n    \n  })\n  \n  write(jsonObject(list(type = \"FeatureCollection\", features = jsonArray(sites))), file = \"www/data/sites.geojson\")\n  \n}\n\ncreateSites()\n\nareaPolygons<- function(spPoly, proj4string = NULL) {\n  if(class(spPoly)[[1]] != \"SpatialPolygonsDataFrame\" & class(spPoly)[[1]] != \"SpatialPolygons\") {\n    stop(\"spPoly must be a SpatialPolygonsDataFrame or a SpatialPolygons object.\")\n  }\n  require(sp)\n  require(rgdal)\n  if(!is.null(proj4string)) {\n    if(class(proj4string)[[1]] != \"CRS\") {\n      stop(\"The proj4string must be of class CRS\")\n    }\n    spP <- spTransform(spPoly, CRS = proj4string)\n  }\n  else {\n    spP <- spPoly\n  }\n  spP <<- spP\n  areas <- lapply(spP@polygons, function(x) {\n    list(round(x@area * 3.86101e-7, 0), unlist(strsplit(x@ID, \" \"))[[1]])\n  }\n  )\n  \n  areas <- do.call(rbind, areas)\n  colnames(areas) <- c(\"area\", \"id\")\n  return(areas)\n}\n\n# Create function to calculate distance in kilometers between two points on the earth\nearth.dist <- function (long1, lat1, long2, lat2){\n  rad = pi/180\n  a1 = lat1 * rad\n  a2 = long1 * rad\n  b1 = lat2 * rad\n  b2 = long2 * rad\n  dlon = b2 - a2\n  dlat = b1 - a1\n  a = (sin(dlat/2))^2 + cos(a1) * cos(b1) * (sin(dlon/2))^2\n  c = 2 * atan2(sqrt(a), sqrt(1 - a))\n  R = 6378.145\n  d = R * c\n  return(d)\n}\n\nneedParams <- function(param, strict = FALSE, message = FALSE, \n                       params = c(\"44201\", \"88101\", \"88502\")) {\n  op <- message\n  if(!is.null(param)) {\n    if(strict) {\n      if(param %in% params) {\n        op <- NULL\n      }\n    } else {\n      if(param != \"-1\") {\n        op <- NULL\n      }\n    }\n  }\n  return(op)\n}",
    "created" : 1422018084184.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "4292213623",
    "id" : "11DE2F54",
    "lastKnownWriteTime" : 1422979210,
    "path" : "C:/R/NetAssessApp/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}