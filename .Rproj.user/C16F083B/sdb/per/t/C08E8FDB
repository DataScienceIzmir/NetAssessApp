{
    "contents" : "library(shiny)\n\nshinyServer(function(input, output, session) {\n  \n  tools <- reactiveValues(cormat = \"download\", output = NULL)\n  values <- reactiveValues()\n  \n  showLoading <- function() {\n    session$sendCustomMessage(\"loading\", \"show\")\n  }\n  \n  hideLoading <- function() {\n    session$sendCustomMessage(\"loading\", \"hide\")\n  }\n  \n  updateSelectInput(session, \"paramOfInterest\", choices = params.list)\n  updateSelectInput(session, \"newSiteParameters\", choices = params.list[2:length(params.list)])\n  \n  # Produce a dataframe of sites that monitor for the selected Parameter of\n  # Interest\n  parameterSites <- reactive({\n    site.list <- NULL\n    if(!is.null(input$paramOfInterest)) {\n      if(input$paramOfInterest != -1) {\n        site.list <- dbGetQuery(db, paste0(\"SELECT sites.* FROM sites JOIN monitors ON sites.Key = monitors.Site_Key WHERE monitors.PARAMETER = \", input$paramOfInterest))\n      }\n    }\n    return(site.list)\n  })\n  \n  newSites.df <- reactive({\n    newSites <- input$newSites\n    if(length(newSites) > 0) {\n      newdf <- data.frame()\n      for(i in seq(length(newSites))) {\n        \n        dr <- c(newSites[[i]]$key, newSites[[i]]$lat, newSites[[i]]$lng)\n        newdf <- rbind(newdf, dr)\n        \n      }\n      colnames(newdf) <- c(\"Key\", \"Latitude\", \"Longitude\")\n      return(newdf)\n    } else {\n      return(NULL)\n    }\n    \n  })\n  \n  visibleSites <- reactive({\n    sites <- parameterSites()\n    ss <- NULL\n    sns <- NULL\n    if(!is.null(sites)) {\n      ss <- sites[sites$Key %in% input$visibleSites, c(\"Key\", \"Latitude\", \"Longitude\")]\n    }\n    newSites <- newSites.df()\n    if(!is.null(newSites)) {\n      sns <- newSites[newSites$Key %in% input$visibleNewSites, ]\n      ss <- rbind(ss, sns)\n    }\n    \n    return(ss)\n    \n  })\n  \n  activeSites <- reactive({\n    selSites <- input$selectedSites\n    visSites <- input$visibleSites\n    actSites <- intersect(selSites, visSites)\n    return(actSites)\n  })\n  \n  activeNewSites <- reactive({\n    selSites <- input$selectedNewSites\n    visSites <- input$visibleNewSites\n    actSites <- intersect(selSites, visSites)\n    return(actSites)  \n  })\n  \n  areaOfInterest <- reactive({\n    \n    aoi <- input$areaOfInterest[[1]]\n    if(is.null(names(aoi[[1]]))) {\n      polygons <- lapply(aoi, function(p) {\n        m <- matrix(as.numeric(do.call(rbind, p)), ncol = 2)\n        m <- rbind(m, m[1, ])\n        m <- m[, c(2, 1)]\n        Polygon(coords = m, hole = FALSE)\n      })\n    } else {\n      m <- matrix(as.numeric(do.call(rbind, aoi)), ncol = 2)\n      m <- rbind(m, m[1, ])\n      m <- m[, c(2, 1)]\n      polygons <- list(Polygon(coords = m, hole = FALSE))\n    }\n    polygons <- SpatialPolygons(list(Polygons(polygons, \"aoi\")))\n\n    return(polygons)\n    \n  })\n  \n  # Send a custom messages to display sites that monitor the selected parameter\n  observe({\n    if(!is.null(parameterSites())) {\n      keys <- unique(parameterSites()$Key)\n    } else {\n      keys <- list()\n    }\n    session$sendCustomMessage(type = \"updateVisibleMonitors\", keys)\n  })\n  \n  observe({\n    if(!is.null(input$areaSelect)) {\n      \n      if(input$areaSelect==\"State\") {\n        choices = state.list\n      } else if(input$areaSelect == \"CBSA\") {\n        choices = cbsa.list\n      } else if(input$areaSelect == \"CSA\") {\n        choices = csa.list\n      } else {\n        choices = c(\"\")\n      }\n\n      updateSelectInput(session, \"areaSelectSelect\", choices = choices)    \n      \n    }\n  })\n  \n  observe({\n\n    if(!is.null(input$areaSelectSelect) && input$areaSelectSelect != \"\") {\n      type <- toupper(isolate(input$areaSelect))\n      src <- switch(type, STATE = \"states\", CBSA = \"cbsas\", CSA = \"csas\")\n      q <- paste0(\"SELECT GEOMETRY FROM \", src, \" WHERE CODE = '\", input$areaSelectSelect, \"'\")\n      coords <- eval(parse(text = dbGetQuery(db, q)[1,1]))\n      session$sendCustomMessage(type=\"displayPredefinedArea\", list(properties = list(name = \"test\", type = type, id = input$areaSelectSelect), coords = coords))  \n    }\n    \n  })\n\n## Area Served ##\n\n  selectedSites <- reactive({\n    \n    sites <- parameterSites()\n    ss <- NULL\n    sns <- NULL\n    if(!is.null(sites)) {\n      ss <- sites[sites$Key %in% activeSites(), c(\"Key\", \"Latitude\", \"Longitude\")]\n    }\n    newSites <- newSites.df()\n    if(!is.null(newSites)) {\n      sns <- newSites[newSites$Key %in% activeNewSites(), ]\n      ss <- rbind(ss, sns)\n    }\n    \n    return(ss)\n    \n  })\n\n  selectedNeighbors <- reactive({\n    \n    ss <- selectedSites()\n\n    all.sites <- visibleSites()\n    \n    op <- NULL\n    \n    if(!is.null(ss) && nrow(ss) != 0) {\n      \n      us.lats <- c(24.4, 49.4)\n      us.lngs <- c(-124.8, -66.9)\n\n      lats <- range(ss$Latitude)\n      lngs <- range(ss$Longitude)\n\n      lat.rng <- max(abs(lats[2] - lats[1]), 1)\n      lng.rng <- max(abs(lngs[2] - lngs[1]), 1)\n\n      gtG <- FALSE\n      \n      while(!gtG) {\n        \n        lats.test <- c(lats[1] - lat.rng, lats[2] + lat.rng)\n        lngs.test <- c(lngs[1] - lng.rng, lngs[2] + lng.rng)\n\n        # Test if us border has been reach in any cardinal direction\n        bounds <- list(north = lats.test[2] >= us.lats[2],\n                       south = lats.test[1] <= us.lats[1],\n                       east =  lngs.test[2] >= us.lngs[2],\n                       west =  lngs.test[1] <= us.lngs[1])\n\n        neighbors <- unique(all.sites[all.sites$Latitude >= lats.test[1] & \n                                    all.sites$Latitude <= lats.test[2] & \n                                    all.sites$Longitude >= lngs.test[1] & \n                                    all.sites$Longitude <= lngs.test[2], ])\n\n        if(!bounds$north) {\n          n <- neighbors[neighbors$Latitude > lats[2], ]\n          bounds$north <- (sum(n$Longitude > lngs[2]) > 0 &\n                             sum(n$Longitude < lngs[1]) > 0 &\n                             sum(n$Longitude < lngs[2] & n$Longitude > lngs[1]) > 0)\n        }\n        if(!bounds$south) {\n          n <- neighbors[neighbors$Latitude < lats[1], ]\n          bounds$south <- (sum(n$Longitude > lngs[2]) > 0 &\n                             sum(n$Longitude < lngs[1]) > 0 &\n                             sum(n$Longitude < lngs[2] & n$Longitude > lngs[1]) > 0)\n        }\n        if(!bounds$east) {\n          n <- neighbors[neighbors$Longitude > lngs[2], ]\n          bounds$east <- (sum(n$Latitude > lats[2]) > 0 &\n                            sum(n$Latitude < lats[1]) > 0 &\n                            sum(n$Latitude < lats[2] & n$Latitude > lats[1]) > 0)\n        }\n        if(!bounds$west) {\n          n <- neighbors[neighbors$Longitude < lngs[1], ]\n          bounds$west <- (sum(n$Latitude > lats[2]) > 0 &\n                            sum(n$Latitude < lats[1]) > 0 &\n                            sum(n$Latitude < lats[2] & n$Latitude > lats[1]) > 0)\n        }\n\n        gtG <- bounds$north & bounds$south & bounds$east & bounds$west\n        \n        lat.rng <- lat.rng * 2\n        lng.rng <- lng.rng * 2\n        \n      }\n\n      neighbors <- neighbors[!duplicated(neighbors[, c(\"Latitude\", \"Longitude\")]), ]\n      v <- deldir(neighbors$Longitude, neighbors$Latitude)\n      x <- v$delsgs\n      x$ind1 <- neighbors$Key[x$ind1]\n      x$ind2 <- neighbors$Key[x$ind2]\n      x <- x[x$ind1 %in% ss$Key | x$ind2 %in% ss$Key, ]\n      x <- unique(c(x$ind1, x$ind2))\n      op <- neighbors[neighbors$Key %in% x, ]\n            \n    }\n    \n    return(op)\n    \n  })\n\n  polygons <- reactive({\n    \n    input$areaServedButton\n    \n    ss <- isolate(selectedSites())\n    \n    # Update this variable to reflect the probability columns present in the tracts dataset\n    probability.columns <- c(\"ozone_prob_75\", \"ozone_prob_70\", \"ozone_prob_65\", \"pm_prob_35\")\n    prob.bin <- function(values) {\n      \n      value = max(values, na.rm = TRUE)\n      \n      if(value < 0.25) {\n        x <- \"<25%\"\n      } else if(value <= 0.5) {\n        x <- \"25%-50%\"\n      } else if(value <= 0.7) {\n        x <- \"50%-70%\"\n      } else if(value <= 0.8) {\n        x <- \"70%-80%\"\n      } else if(value <= 0.9) {\n        x <- \"80%-90%\"\n      } else if(value <= 1) {\n        x <- \">90%\"\n      } else {\n        x <- \"NA\"\n      }\n      \n      return(x)\n      \n    }\n        \n    if(input$areaServedType == \"voronoi\") {\n  \n      if(!is.null(ss) && nrow(ss) != 0) {\n        \n        sn <- isolate(selectedNeighbors())\n          \n        if(!is.null(ss) && nrow(ss) != 0) {\n          if(nrow(ss) <= 400 & nrow(sn) >= 2) {\n           if(input$areaServedClipping == \"none\") {\n             v <- voronoi(sn$Key, sn$Latitude, sn$Longitude)\n           } else {\n             if(input$areaServedClipping == \"border\") {\n               b <- usborder\n             } else {\n               b <- areaOfInterest()\n             }\n             v <- voronoi(sn$Key, sn$Latitude, sn$Longitude, b)\n           }\n  \n            v <- subset(v, id %in% ss$Key)\n            \n            ov <- over(tracts, v)\n            t <- cbind(as.data.frame(tracts), ov)\n            t <- t[!is.na(t$id), ]\n            d <- aggregate(t[, sapply(seq(ncol(t)), function(i) {is.integer(t[, i])})], by = list(as.character(t$id)), FUN = sum, na.rm = TRUE)\n            d2 <- aggregate(t[, probability.columns], by = list(as.character(t$id)), FUN = prob.bin)\n            proj4string(v) <- CRS(\"+proj=longlat +ellps=WGS84\")\n            area <- areaPolygons(v, CRS(\"+init=epsg:2163\")) \n            \n            v@data <- merge(v@data, d, by.x=\"id\", by.y = \"Group.1\", all.x = TRUE, all.y = FALSE)\n            v@data <- merge(v@data, d2, by.x = \"id\", by.y = \"Group.1\", all.x = TRUE, all.y = FALSE)\n            v@data <- merge(v@data, area, by = \"id\", all.x = TRUE, all.y = FALSE)\n          } else {\n            v <- NULL\n          }\n        } else {\n          v <- NULL\n        }\n  \n        return(v)\n        \n      }\n      \n    } else {\n      \n      ## This is where circular area served code will go.\n      \n    }\n  \n  })\n\n  observe({\n    \n    if(!is.null(polygons())) {\n      polygons <- polygons()\n      v <- lapply(seq(nrow(polygons)), function(i) {\n        list(id = unlist(strsplit(polygons@polygons[[i]]@ID, \" \"))[1], \n             coords = lapply(polygons@polygons[[i]]@Polygons, function(pp) {\n               coords <- pp@coords\n               apply(coords, 1, function(r) {\n                 list(lat = r[[2]], lng = r[[1]])\n               })\n             })\n        )\n      })\n      session$sendCustomMessage(type = \"updateAreaServed\", v)\n    }\n    \n  })\n\n  selectedParameter <- reactive({\n    return(list(code = input$paramOfInterest, name = params$Parameter_Desc[params$Parameter_Code == input$paramOfInterest]))\n  })\n  \n  areaServedMonitor <- reactive({\n    monkey <- as.numeric(input$clickedAreaServed)\n    if(length(monkey) > 0) {\n      if(monkey < 90000) {\n        sites <- isolate(parameterSites());\n        mon <- sites[sites$Key %in% monkey, ]\n        mon <- sprintf(\"%02i-%03i-%04i\", mon$State_Code, mon$County_Code, mon$Site_ID)\n      } else {\n        mon <- paste(input$newSites[monkey]$properties$name, \"(New Site)\")\n      }\n      return(mon)\n    }\n  })\n\n\n  output$areaServedParameter <- renderText({\n    selectedParameter()$name\n  })\n\n  output$areaServedArea <- renderText({\n    polygons <- polygons()\n    if(!is.null(polygons)) {\n      data <- polygons@data\n      km2 <- as.numeric(data$area[data$id == input$clickedAreaServed])\n      mi2 <- round(km2 * 0.38610215854, 0)\n      txt <- paste0(\"<b>Area</b>: \", format(mi2, big.mark = \",\"), \"mi<sup>2</sup> (\", format(km2, big.mark = \",\"), \"km<sup>2</sup>)\")\n    } else {\n      txt <- \"\"\n    }\n    return(txt)\n  })\n\n  output$areaServedMonitor <- renderText({\n    areaServedMonitor()\n  })\n\n  output$naaqsProb <- renderText({\n    \n    data <- as.data.frame(polygons())\n    data <- data[data$id == input$clickedAreaServed, ]\n    \n    prob <- \"Not Available\"\n    \n    if(!is.null(input$paramOfInterest)) {\n    \n      if(input$paramOfInterest == 44201) {\n        if(input$ozoneNAAQS == \"65ppb\") {\n          prob <- data$ozone_prob_65[1]\n        } else if(input$ozoneNAAQS == \"70ppb\") {\n          prob <- data$ozone_prob_70[1]\n        } else {\n          prob <- data$ozone_prob_75[1]\n        }\n        prob <- paste0(\"<b>Maximum Probability</b>: \", prob)\n      } else if(input$paramOfInterest %in% c(88101, 88502)) {\n        prob <- paste0(\"<b>Maximum Probability</b>: \", data$pm_prob_35[1])\n      }\n    }\n    \n    return(prob)    \n    \n  })\n\n  output$areaServedPopulation <- renderText({\n    input$clickedAreaServed\n    polygons <- polygons()\n    if(!is.null(polygons)) {\n      data <- polygons@data\n      txt <- paste(\"<b>Total Population</b>:\", format(data$total[data$id == input$clickedAreaServed], big.mark = \",\"))\n    } else {\n      txt <- \"\"\n    }\n    return(txt)\n  })\n\n  output$areaServedAgePlot <- renderPlot({\n    \n    input$clickedAreaServed\n    \n    if(!is.null(input$clickedAreaServed)) {\n      p <- params$Parameter_Desc[params$Parameter_Code == input$paramOfInterest]\n      title <- paste0(p, \" - Area Served by \", areaServedMonitor())\n      gg <- agePyramid(polygons()@data, input$clickedAreaServed) + ggtitle(title)\n      suppressWarnings(print(gg))\n      \n    }\n  }, width = 788, height = 900)\n\n  output$areaServedRacePlot <- renderPlot({\n    \n    input$clickedAreaServed\n    \n    if(!is.null(input$clickedAreaServed)) {\n      \n      data <- as.data.frame(polygons())\n      data <- data[data$id == input$clickedAreaServed,  c(\"white\", \"black\", \"native\", \"asian\", \"islander\", \"other\", \"multiple\")]\n      \n      data <- data.frame(label = c(\"White\", \"African American\", \"Native American\", \"Asian\", \"Native Hawaiian/Pacific Islander\", \"Other\", \"Two or More\"),\n                         count = unlist(data))\n      \n      title <- paste0(\"Area Served by \", areaServedMonitor())\n      \n      plt <- ggplot(data, aes(x = label, y = count)) + theme_bw(base_size = 16) + \n        geom_bar(stat = \"identity\", fill = \"turquoise3\" ) +\n        labs(x = \"Race\", y = \"Population\") + \n        theme(axis.text.x = element_text(angle = 20, hjust = 1)) + ggtitle(title)  \n      \n      plt\n      \n    }\n    \n  }, width = 788, height = 900)\n\n  trendChart <- observe({\n    \n    site <- input$popupID\n    param <- input$paramOfInterest\n      \n    if(!is.null(site) && !is.null(param)) {\n      \n      dv <- dbGetQuery(db, paste0(\"SELECT dv.*, crit_lu.NAME, naaqs.STANDARD, naaqs.UNITS FROM dv JOIN crit_lu ON dv.POLLUTANT = crit_lu.CODE JOIN naaqs ON dv.DURATION = naaqs.DURATION AND dv.POLLUTANT = naaqs.POLLUTANT WHERE crit_lu.PARAMETER = \", param, \" AND dv.Key = \", site))\n\n      if(nrow(dv) > 0) {\n        \n        values$trendChart <- paste0(\"images/temp/trend\", as.integer(runif(1,1,1000000)), \".png\")\n        \n        trendChart <- plotPNG(function() {\n          \n          pol <- dv$NAME[1]\n          site <- sprintf(\"%02i-%03i-%04i\", dv$STATE_CODE, dv$COUNTY_CODE, dv$SITE_ID)[1]\n          if(pol == \"PM<sub>2.5</sub>\") {\n            title <- bquote(paste(\"Design Value Trends: \", PM[2.5], \" at \", .(site)))\n          } else if(pol == \"PM<sub>10</sub>\") {\n            title <- bquote(paste(\"Design Value Trends: \", PM[10], \" at \", .(site)))\n          } else {\n            title <- paste(\"Design Value Trends:\", pol, \"at\", site)\n          }\n          pol <- gsub(\"<sub>\", \"[\", pol, fixed = TRUE)\n          pol <- gsub(\"</sub>\", \"]\", pol, fixed = TRUE)\n          units <- dv$UNITS[1]\n          if(units == \"ugm3\") {\n            yaxis <- expression(paste(\"Design Value (\", mu*g/m^3, \")\"))\n          } else {\n            yaxis <- paste0(\"Design Value (\", units, \")\")\n          }\n          \n          dv <- dv[, c(\"DURATION\", \"STANDARD\", \"DV_2004\", \"DV_2005\", \"DV_2006\", \"DV_2007\", \"DV_2008\", \"DV_2009\", \"DV_2010\", \"DV_2011\", \"DV_2012\", \"DV_2013\")] \n          dv <- melt(dv)\n          \n          std <- dv[dv$variable == \"STANDARD\", c(\"DURATION\", \"value\")]\n          colnames(std) <- c(\"DURATION\", \"STANDARD\")\n          dv <- dv[dv$variable != \"STANDARD\", ]\n          colnames(dv) <- c(\"DURATION\", \"LABEL\", \"DV\")\n          dv <- merge(dv, std, by = \"DURATION\")\n          dv$LABEL <- as.numeric(substr(as.character(dv$LABEL), 4, 7))\n          dv$SNAME <- paste(dv$DURATION, \"Standard\")\n          dv$DURATION <- paste(dv$DURATION, \"Design Value\")\n          \n          cbPalette <- c(\"#E69F00\", \"#D55E00\", \"#56B4E9\", \"#0072B2\")\n                  \n          plt <- ggplot(dv, aes(x = LABEL, y = DV, colour = DURATION, ymin = 0)) + labs(colour = \"\") +\n            geom_hline(aes(yintercept = STANDARD, colour = SNAME), show_guide = TRUE, size = 1.25) +\n            geom_line(size = 1.5) +\n            geom_point(size = 4) +\n            labs(x = \"Year\", y = yaxis) + \n            theme_bw(base_size = 16) + theme(legend.position=\"bottom\") + \n            scale_colour_manual(values=cbPalette) +\n            ggtitle(title)\n          \n          print(plt)\n          \n        }, width = 900, height = 450, filename = paste0(\"www/\", values$trendChart))\n        \n        session$sendCustomMessage(type = \"updateTrendChart\", values$trendChart)\n        \n      }\n      \n    }\n  })\n\n  readings <- reactive({\n    \n    validate(\n      need(selectedNeighbors(), message = FALSE),\n      needParams(input$paramOfInterest, strict = TRUE)\n    )\n    \n    param <- input$paramOfInterest\n    sn <- selectedNeighbors()\n    \n    validParams <- c(\"44201\", \"88101\", \"88502\")\n    \n    op <- NULL\n    \n    if(param %in% validParams && !is.null(sn)) {\n      showLoading()\n      sql <- isolate({paste0(\"SELECT sites.Key AS Site_Key, sites.State_Code, sites.County_Code, sites.Site_ID, sites.Latitude, sites.Longitude, monitors.Key AS Monitor_Key, monitors.POC, readings.Date, readings.Value, readings.Duration_Code FROM sites JOIN monitors ON sites.Key = monitors.Site_Key JOIN readings ON monitors.Key = readings.Key WHERE monitors.Parameter = \", param, \" AND sites.Key IN ('\", paste0(sn$Key, collapse = \"', '\"), \"')\")})\n      q <- dbGetQuery(db, sql)\n      if(nrow(q) > 0) {\n        op <- q\n      }\n      hideLoading()    \n    }\n\n    return(op)\n    \n  })\n\n  cormatTable <- reactive({\n    \n    op <- NULL\n      \n    r <- readings()\n    \n    if(!is.null(r)) {\n      \n      if(input$paramOfInterest == \"88101\") {\n      \n        if(input$pmType == \"frm\") {\n          r <- r[r$Duration_Code == \"7\", ]\n        } else if(input$pmType == \"fem\") {\n          r <- r[r$Duration_Code == \"X\", ]\n        }\n        \n      }\n      \n      r <- r[r$Site_Key %in% activeSites(), ]\n      \n      if(nrow(r) > 0) {\n        showLoading()\n        op <- cormatData(r)  \n        hideLoading()\n      }\n      \n    }\n    \n    return(op)\n  \n  })\n\n  output$cormatChart <- renderPlot({\n  \n    validate(need(input$cormatButton, FALSE))\n    \n    input$cormatButton\n    \n    isolate({\n    \n      if(is.null(cormatTable())) {\n        if(input$cormatButton > 0) {\n          session$sendCustomMessage(\"showCormat\", TRUE)\n          return({\n            plot(x = 0.5, y = 0.5, col = \"white\", axes = FALSE, xlab = \"\", ylab = \"\")\n            text(x = 0.5, y = 0.5, cex = 4, labels = \"Insufficient data avaialable\")\n          })\n        }\n      } else {\n        session$sendCustomMessage(\"showCormat\", TRUE)\n        return(cormatChart(cormatTable(), isolate(input$paramOfInterest), isolate(input$pmType)))\n      }\n    \n    })\n      \n  }, width = 1800, height = 1350)\n\n  observeEvent(input$cormapSite, {\n    \n    d <- cormatTable()\n    if(!is.null(cormatTable())) {\n      if(!is.null(input$cormapSite)) {\n        d <- d[d$key1 %in% input$cormapSite | d$key2 %in% input$cormapSite, ]\n        if(nrow(d) > 0) {\n          d$site <- sapply(seq(nrow(d)), function(i) {\n            if(d$key1[i] %in% input$cormapSite) {\n              return(d$key2[i])\n            } else {\n              return(d$key1[i])\n            }\n          })\n          d <- d[, c(\"site\", \"cor\", \"com\", \"dif\", \"dis\")]\n          session$sendCustomMessage(\"updateCorMap\", d)\n        }\n      }\n    }\n    \n  })\n\n  output$correlationDataDownload <- downloadHandler(filename = function() {paste0(\"netassess-correlation-\", input$paramOfInterest, \"-\", Sys.Date(), \".csv\")},\n                                                    content = function(file) {\n                                                      df <- cormatTable()\n                                                      df <- df[, c(\"site1\", \"site2\", \"cor\", \"com\", \"dif\", \"dis\")]\n                                                      colnames(df) <- c(\"Site 1\", \"Site 2\", \"Correlation\", \"n\", \"Rel. Diff\", \"Distance (km)\")  \n                                                      write.csv(df, file, row.names = FALSE)\n                                                    })\n\n\n  rembiasTable <- reactive({\n    \n    r <- readings()\n    op <- NULL\n    \n    if(!is.null(r)) {\n      \n      sN <- isolate({selectedNeighbors()})\n      sN <- sN[sN$Key %in% r$Site_Key, ]\n      \n      sites.deldir <- deldir(sN$Longitude, sN$Latitude)\n      combos <- sites.deldir$delsgs\n      \n      combos$dist <- mapply(FUN = earth.dist, long1 = combos[, 1],\n                            lat1 = combos[, 2], long2 = combos[, 3],\n                            lat2 = combos[, 4])\n      \n      combos$ind1 <- sN$Key[combos$ind1]\n      combos$ind2 <- sN$Key[combos$ind2]\n      \n      d <<- list(sN, sites.deldir, combos, activeSites = activeSites(), data)\n      \n      rb <- lapply(activeSites(), function(site) {\n        \n        site.data <- r[r$Site_Key == site, c(\"Date\", \"Value\")]\n        \n        if(nrow(site.data) > 0) {\n          \n          start.date <- min(site.data$Date)\n          end.date <- max(site.data$Date)\n          \n          neighbors <- combos[combos$ind1 == site | combos$ind2 == site, ]\n          neighbors$Site_Key <- apply(neighbors, 1, function(r) {if(r['ind1'] == site) {return(r['ind2'])} else {return(r['ind1'])}})\n          neighbors <- neighbors[, c(\"Site_Key\", \"dist\")]\n          neigh.data <- r[r$Site_Key %in% neighbors$Site_Key, c(\"Site_Key\", \"Date\", \"Value\")]\n          neigh.data <- merge(neigh.data, neighbors, by = \"Site_Key\", all = TRUE)\n          neigh.data <- neigh.data[neigh.data$Date %in% site.data$Date, ] \n          \n          values <- as.matrix(dcast(neigh.data, Date~Site_Key, value.var = \"Value\", fun.aggregate = mean))\n          rownames(values) <- values[,1]\n          values <- values[, -1]\n          weights <- dcast(neigh.data, Date~Site_Key, value.var = \"dist\", fun.aggregate = mean)\n          rownames(weights) <- weights[,1]\n          weights <- weights[, -1]\n          weights <- 1/(weights^2)\n          values[is.na(values)] = 0\n          weights[is.na(weights)] = 0\n          \n          # multiply the values and weights matrices and calculate inner product using \n          # a vector of ones to get the sums for each row \n          summed <- (values * weights) %*% rep(1, dim(values)[2])\n          \n          # calculate the sum of each row in the \n          denom <- weights %*% rep(1, dim(values)[2])\n          \n          # if the denom vector has zeros, remove that index from denom and summed\n          rn <- rownames(summed)\n          summed <- summed[denom != 0]\n          denom <- denom[denom != 0]\n          \n          # calculate inverse distance squared weighted average for each day\n          weighted.avg <- summed / denom\n          weighted.avg <- data.frame(Date = rn, Est = weighted.avg)\n          \n          # get the daily values for the monitor of interest as a vector\n          daily <- merge(site.data, weighted.avg, by =\"Date\")\n          \n          # calculate difference between each interpolated value and the actual\n          # value for the monitor\n          daily$diff <- daily$Est - daily$Value \n          x <- daily$Value != 0\n          relDiff <- round(100 * (daily$diff[x]/daily$Value[x]))\n          daily$diff <- signif(daily$diff, 3)\n          \n          data.frame(Key = site, bias_mean = round(mean(daily$diff), 4), bias_min = min(daily$diff),\n                     bias_max = max(daily$diff), bias_sd = sd(daily$diff), bias_n = nrow(neighbors),\n                     relbias_mean = round(mean(relDiff)), relbias_min = min(relDiff),\n                     relbias_max = max(relDiff), start_date = start.date, end_date = end.date)\n          \n        }\n        \n      })\n      \n      s <- do.call(rbind, rb)\n      \n      if(nrow(s) == 0) {\n        s <- NULL\n      } else {\n        siteIDs <- unique(r[, c(\"Site_Key\", \"State_Code\", \"County_Code\", \"Site_ID\")])\n        siteIDs$id <- sprintf(\"%02i-%03i-%04i\", siteIDs$State_Code, siteIDs$County_Code, siteIDs$Site_ID)\n        siteIDs <- siteIDs[, c(\"Site_Key\", \"id\")]\n        s <- merge(s, siteIDs, by.x = \"Key\", by.y = \"Site_Key\", all.x = TRUE, all.y = FALSE)\n      }\n\n      op <- s\n      \n    } \n    \n    return(op)\n    \n  })\n\n  observeEvent(input$rembiasButton, {\n    \n    validate(need(rembiasTable(), FALSE))\n    \n    isolate({\n    \n      if(!is.null(rembiasTable())) {\n        session$sendCustomMessage(\"rembiasUpdate\", list(data = rembiasTable()))  \n      }\n    \n    })\n    \n  })\n\n  output$rembiasDataDownload <- downloadHandler(filename = function() {paste0(\"netassess-rembias-\", input$paramOfInterest, \"-\", Sys.Date(), \".csv\")},\n                                                    content = function(file) {\n                                                      df <- rembiasTable()\n                                                      df <- df[, c(\"id\", \"bias_mean\", \"bias_min\", \"bias_max\", \"bias_sd\", \"bias_n\", \"relbias_mean\", \"relbias_min\", \"relbias_max\")]\n                                                      colnames(df) <- c(\"Site ID\", \"Mean Removal Bias\", \"Min Removal Bias\", \"Max Removal Bias\", \"Removal Bias Standard Deviation\", \"Neighbors Included\", \"Mean Relative Removal Bias (%)\", \"Min Relative Removal Bias (%)\", \"Max Relative Removal Bias (%)\")\n                                                      write.csv(df, file, row.names = FALSE)\n                                                    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  output$sitesDataDownload <- downloadHandler(filename = function() {paste0(\"netassess-sites-\", input$paramOfInterest, \"-\", Sys.Date(), \".csv\")},\n                                              content = function(file) {\n                                                param <- input$paramOfInterest\n                                                s <- parameterSites()[parameterSites()$Key %in% activeSites(), ]\n                                                d <- dbGetQuery(db, paste0(\"SELECT dv.*, crit_lu.NAME, naaqs.STANDARD, naaqs.UNITS FROM dv JOIN crit_lu ON dv.POLLUTANT = crit_lu.CODE JOIN naaqs ON dv.DURATION = naaqs.DURATION AND dv.POLLUTANT = naaqs.POLLUTANT WHERE crit_lu.PARAMETER = \", param, \" AND dv.Key IN (\", paste0(activeSites(), collapse = \", \"), \")\"))\n                                                if(nrow(d) > 0) {\n                                                  s <- merge(s, d, on=\"Key\", all.x = TRUE, all.y = FALSE)\n                                                  s$Parameter <- d$NAME[1]\n                                                  s$Units <- d$UNITS[1]\n                                                  s$Standard <- d$STANDARD[1]\n                                                } else {\n                                                  s <- s[, c(\"State_Code\", \"County_Code\", \"Site_ID\", \"Latitude\", \"Longitude\", \"Street_Address\", \"Count\", \"Crit_Count\", \"HAP_Count\", \"Met_Count\")]\n                                                  colnames(s) <- c(\"State_Code\", \"County_Code\", \"Site_ID\", \"Latitude\", \"Longitude\", \"Street_Address\", \"Parameter_Count\", \"Criteria_Parameter_Count\", \"HAP_Parameter_Count\", \"Meteorology_Parameter_Count\")\n                                                }\n                                               \n                                                s$County_Code <- sprintf(\"%03i\", as.integer(s$County_Code))\n                                                s$Site_ID <- sprintf(\"%04i\", as.integer(s$Site_ID))\n                                                \n                                                write.csv(s, file, row.names = FALSE)\n                                                \n                                              })\n\n\n  output$areaServedDataDownload <- downloadHandler(filename = function() {paste0(\"netassess-areaserved-\", input$paramOfInterest, \"-\", Sys.Date(), \".csv\")},\n                                                   content = function(file) {\n                                                     d <- polygons()@data\n                                                     d$area <- unlist(d$area)\n                                                     write.csv(d, file = file)                             \n                                                   })\n\n})",
    "created" : 1421774970093.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1419837534",
    "id" : "C08E8FDB",
    "lastKnownWriteTime" : 1423068797,
    "path" : "C:/R/NetAssessApp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}