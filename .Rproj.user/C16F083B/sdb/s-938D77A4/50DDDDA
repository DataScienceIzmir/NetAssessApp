{
    "contents" : "library(shiny)\n\nshinyServer(function(input, output, session) {\n#  options(shiny.trace=TRUE)\n#### Functions for controlling parameter selection\n  \n  values <- reactiveValues();\n  \n  # Populate the parameter selection dropdown  \n  updateSelectInput(session, \"expParam\", choices = params.list)\n  updateSelectInput(session, \"new_site_parameters\", choices = params.list[2:length(params.list)])\n  \n  # Contains a list of sites based on the currently selected parameter\n  sites <- reactive({\n    if(!is.null(input$expParam)) {\n      if(input$expParam != -1) {\n        site.list <- dbGetQuery(db, paste0(\"SELECT sites.* FROM sites JOIN monitors ON sites.Key =  monitors.Site_Key WHERE monitors.PARAMETER = \", input$expParam))\n        return(site.list)\n      } else {return(NULL)}\n    } else {return(NULL)}\n  })\n  \n  visibleNewSites <- reactive({\n    new_sites <- input$newSites$data\n    if(length(new_sites) > 0) {\n      vns <- data.frame(stringsAsFactors = FALSE)\n      for(i in seq(length(new_sites))) {\n        n <- new_sites[[i]]\n        if(n$visible == TRUE) {\n          vns <- rbind(vns, c(n$lat, n$lng, n$key, n$selected, n$name))\n        }\n      }\n      \n      colnames(vns) <- c(\"Latitude\", \"Longitude\", \"Key\", \"selected\", \"name\")\n      vns$Latitude <- as.numeric(vns$Latitude)\n      vns$Longitude <- as.numeric(vns$Longitude)\n      vns$selected <- as.logical(vns$selected)\n      return(vns)\n    }\n  })\n  \n  selectedNewSites <- reactive({\n    vns <- visibleNewSites()\n    return(vns[vns$selected, ])\n  })\n  \n  visibleSites <- reactive({\n    \n    return(sites()[sites()$Key %in% input$visibleSites, ])\n    \n  })\n\n  # Send a custom message to update visible monitors based on parameter selection\n  observe({\n    if(!is.null(sites())) {\n      keys <- unique(sites()$Key)\n    } else {\n      keys <- list()\n    }\n    session$sendCustomMessage(type=\"updateVisibleMonitors\", keys)\n  })\n  \n#### Functions for controlling the Area of Interest Selection\n\n  # Observer to update predefined area select input based on Area Type\n  observe({\n    \n    if(!is.null(input$areaSelect)) {\n      \n      if(input$areaSelect==\"State\") {\n        choices = state.list\n      } else if(input$areaSelect == \"CBSA\") {\n        choices = cbsa.list\n      } else if(input$areaSelect == \"CSA\") {\n        choices = csa.list\n      } else {\n        choices = c(\"\")\n      }\n      \n      updateSelectInput(session, \"areaSelectSelect\", choices = choices)\n      \n    }\n    \n  })\n\n  # Send the geometry for a predefined area selection\n  observe({\n    \n    if(!is.null(input$areaSelectSelect)) {\n      \n      type <- toupper(isolate(input$areaSelect))\n      \n      src <- switch(type, STATE = \"states\", CBSA = \"cbsas\", CSA = \"csas\")\n      \n      q <- paste0(\"SELECT GEOMETRY FROM \", src, \" WHERE CODE = '\", input$areaSelectSelect, \"'\")\n      \n      coords <- eval(parse(text = dbGetQuery(db, q)[1,1]))\n      \n      session$sendCustomMessage(type=\"displayPredefinedArea\", list(properties = list(name = \"test\", type = type, id = input$areaSelectSelect), coords = coords))\n      \n    }\n    \n  })\n\n##### Area Served Functions\n\n  selectedSites <- reactive({\n\n      sites <- sites()\n      if(!is.null(sites)) {\n        ss <- sites[sites$Key %in% input$selectedSites, c(\"Key\", \"Latitude\", \"Longitude\")]\n        if(nrow(ss) == 0) {ss <- NULL}\n      } else {\n        ss <- NULL\n      }\n\n      return(ss)\n    \n  })\n\n  selectedNeighbors <- reactive({\n\n    ss <- selectedSites()\n    ss <<- ss\n    nss <- selectedNewSites()[, c(\"Key\", \"Latitude\", \"Longitude\")]\n    nss <<- nss\n    sss <- isolate(visibleSites()[, c(\"Key\", \"Latitude\", \"Longitude\")])\n    sss <<- sites\n    newsites <- isolate(visibleNewSites()[, c(\"Key\", \"Latitude\", \"Longitude\")])\n    newsites <<- newsites\n    \n    ss <- rbind(ss, nss)\n    sites <- rbind(sss, newsites)\n\n    \n    \n    if(!is.null(ss)) {\n        \n      us.lats <- c(24.4, 49.4)\n      us.lngs <- c(-124.8, -66.9)\n      \n      lats <- range(ss$Latitude)\n      lngs <- range(ss$Longitude)\n      \n      lat.rng <- max(abs(lats[2] - lats[1]), 1)\n      lng.rng <- max(abs(lngs[2] - lngs[1]), 1)\n          \n      gtG <- FALSE\n      \n      while(!gtG) {\n        \n        lats.test <- c(lats[1] - lat.rng, lats[2] + lat.rng)\n        lngs.test <- c(lngs[1] - lng.rng, lngs[2] + lng.rng)\n        \n        # Test if us border has been reach in any cardinal direction\n        bounds <- list(north = lats.test[2] >= us.lats[2],\n                       south = lats.test[1] <= us.lats[1],\n                       east =  lngs.test[2] >= us.lngs[2],\n                       west =  lngs.test[1] <= us.lngs[1])\n\n        neighbors <- unique(sites[sites$Latitude >= lats.test[1] & \n                                  sites$Latitude <= lats.test[2] & \n                                  sites$Longitude >= lngs.test[1] & \n                                  sites$Longitude <= lngs.test[2], ])\n\n        if(!bounds$north) {\n          n <- neighbors[neighbors$Latitude > lats[2], ]\n          bounds$north <- (sum(n$Longitude > lngs[2]) > 0 &\n                           sum(n$Longitude < lngs[1]) > 0 &\n                           sum(n$Longitude < lngs[2] & n$Longitude > lngs[1]) > 0)\n        }\n        if(!bounds$south) {\n          n <- neighbors[neighbors$Latitude < lats[1], ]\n          bounds$south <- (sum(n$Longitude > lngs[2]) > 0 &\n                             sum(n$Longitude < lngs[1]) > 0 &\n                             sum(n$Longitude < lngs[2] & n$Longitude > lngs[1]) > 0)\n        }\n        if(!bounds$east) {\n          n <- neighbors[neighbors$Longitude > lngs[2], ]\n          bounds$east <- (sum(n$Latitude > lats[2]) > 0 &\n                             sum(n$Latitude < lats[1]) > 0 &\n                             sum(n$Latitude < lats[2] & n$Latitude > lats[1]) > 0)\n        }\n        if(!bounds$west) {\n          n <- neighbors[neighbors$Longitude < lngs[1], ]\n          bounds$west <- (sum(n$Latitude > lats[2]) > 0 &\n                            sum(n$Latitude < lats[1]) > 0 &\n                            sum(n$Latitude < lats[2] & n$Latitude > lats[1]) > 0)\n        }\n        \n        gtG <- bounds$north & bounds$south & bounds$east & bounds$west\n              \n        lat.rng <- lat.rng * 2\n        lng.rng <- lng.rng * 2\n        \n      }\n      \n      neighbors <- neighbors[!duplicated(neighbors[, c(\"Latitude\", \"Longitude\")]), ]\n      v <- deldir(neighbors$Longitude, neighbors$Latitude)\n      x <- v$delsgs\n      x$ind1 <- neighbors$Key[x$ind1]\n      x$ind2 <- neighbors$Key[x$ind2]\n      x <- x[x$ind1 %in% ss$Key | x$ind2 %in% ss$Key, ]\n      x <- unique(c(x$ind1, x$ind2))\n    \n      return(neighbors[neighbors$Key %in% x, ])\n    \n    }\n    \n  })\n\n  polygons <- reactive({\n    \n    input$areaServedCalcButton\n    \n    ss <- isolate(selectedSites())\n    nss <- isolate(selectedNewSites()[, c(\"Key\", \"Latitude\", \"Longitude\")])\n    ss <- rbind(ss, nss)\n    if(!is.null(nrow(ss))) {\n      \n      sn <- isolate(selectedNeighbors())\n      \n      # Update this variable to reflect the probability columns present in the tracts dataset\n      probability.columns <- c(\"ozone_prob_75\", \"ozone_prob_70\", \"ozone_prob_65\", \"pm_prob_35\")\n      prob.bin <- function(values) {\n        \n        value = max(values, na.rm = TRUE)\n        \n        if(value < 0.25) {\n          x <- \"<25%\"\n        } else if(value <= 0.5) {\n          x <- \"25%-50%\"\n        } else if(value <= 0.7) {\n          x <- \"50%-70%\"\n        } else if(value <= 0.8) {\n          x <- \"70%-80%\"\n        } else if(value <= 0.9) {\n          x <- \"80%-90%\"\n        } else if(value <= 1) {\n          x <- \">90%\"\n        } else {\n          x <- \"NA\"\n        }\n        \n        return(x)\n        \n      }\n      \n      if(!is.null(ss)) {\n        if(nrow(ss) <= 400 & nrow(sn) >= 2) {\n          if(input$areaServedClipping == \"none\") {\n            v <- voronoi(sn$Key, sn$Latitude, sn$Longitude)\n          } else {\n            if(input$areaServedClipping == \"border\") {\n              b <- usborder\n            } else {\n              b <- areaOfInterest()\n            }\n            v <- voronoi(sn$Key, sn$Latitude, sn$Longitude, b)\n          }\n          v <- subset(v, id %in% ss$Key)\n\n          ov <- over(tracts, v)\n          t <- cbind(as.data.frame(tracts), ov)\n          t <- t[!is.na(t$id), ]\n          test <<- t\n          vest <<- v\n          d <- aggregate(t[, sapply(seq(ncol(t)), function(i) {is.integer(t[, i])})], by = list(as.character(t$id)), FUN = sum, na.rm = TRUE)\n          d2 <- aggregate(t[, probability.columns], by = list(as.character(t$id)), FUN = prob.bin)\n          proj4string(v) <- CRS(\"+proj=longlat +ellps=WGS84\")\n          area <- areaPolygons(v, CRS(\"+init=epsg:2163\")) \n\n          v@data <- merge(v@data, d, by.x=\"id\", by.y = \"Group.1\", all.x = TRUE, all.y = FALSE)\n          v@data <- merge(v@data, d2, by.x = \"id\", by.y = \"Group.1\", all.x = TRUE, all.y = FALSE)\n          v@data <- merge(v@data, area, by = \"id\", all.x = TRUE, all.y = FALSE)\n          #ids <- sapply(v@data$id, function(i) {strsplit(i, \" \")[[1]][1]})\n          #v@data$id <- ids\n        } else {\n          v <- NULL\n        }\n      } else {\n        v <- NULL\n      }\n\n      return(v)\n    }\n  })\n\n  observe({\n    if(!is.null(polygons())) {\n      polygons <- polygons()\n      v <- lapply(seq(nrow(polygons)), function(i) {\n        list(id = unlist(strsplit(polygons@polygons[[i]]@ID, \" \"))[1], \n             coords = lapply(polygons@polygons[[i]]@Polygons, function(pp) {\n                coords <- pp@coords\n                apply(coords, 1, function(r) {\n                  list(lat = r[[2]], lng = r[[1]])\n                })\n              })\n        )\n      })\n      session$sendCustomMessage(type = \"updateAreaServed\", v)\n    }\n  })\n\n  areaServedMonitor <- reactive({\n    monkey <- as.numeric(input$clickedAreaServed)\n    if(length(monkey) > 0) {\n      if(monkey < 90000) {\n        sites <- isolate(sites())\n        mon <- sites[sites$Key %in% monkey, ]\n        mon <- sprintf(\"%02i-%03i-%04i\", mon$State_Code, mon$County_Code, mon$Site_ID)\n      } else {\n        sites <- isolate(visibleNewSites())\n        mon <- paste(sites[sites$Key %in% monkey, \"name\"], \"(New Site)\")\n      }\n      return(mon)\n    }\n  })\n\n  selectedParameter <- reactive({\n    return(list(code = input$expParam, name = params$Parameter_Desc[params$Parameter_Code == input$expParam]))\n  })\n\n  output$areaServedParameter <- renderText({\n    selectedParameter()$name\n  })\n\n  output$areaServedMonitor <- renderText({\n    areaServedMonitor()\n  })\n\n  areaOfInterest <- reactive({\n    \n    aoi <- input$areaOfInterest\n    aoi <- aoi[[1]]\n    if(is.null(names(aoi[[1]]))) {\n      polygons <- lapply(aoi, function(p) {\n        m <- matrix(as.numeric(do.call(rbind, p)), ncol = 2)\n        m <- rbind(m, m[1, ])\n        m <- m[, c(2, 1)]\n        Polygon(coords = m, hole = FALSE)\n      })\n    } else {\n      m <- matrix(as.numeric(do.call(rbind, aoi)), ncol = 2)\n      m <- rbind(m, m[1, ])\n      m <- m[, c(2, 1)]\n      polygons <- list(Polygon(coords = m, hole = FALSE))\n    }\n    polygons <- SpatialPolygons(list(Polygons(polygons, \"aoi\")))\n    return(polygons)\n    \n  })\n\n  output$areaServed <- renderText({\n    input$clickedAreaServed\n    polygons <- polygons()\n    if(!is.null(polygons)) {\n      data <- polygons@data\n      km2 <- as.numeric(data$area[data$id == input$clickedAreaServed])\n      mi2 <- round(km2 * 0.38610215854, 0)\n      txt <- paste0(\"<b>Area</b>: \", format(mi2, big.mark = \",\"), \"mi<sup>2</sup> (\", format(km2, big.mark = \",\"), \"km<sup>2</sup>)\")\n    } else {\n      txt <- \"\"\n    }\n    return(txt)\n  })\n\n  output$totalPopServed <- renderText({\n    input$clickedAreaServed\n    polygons <- polygons()\n    if(!is.null(polygons)) {\n      data <- polygons@data\n      txt <- paste(\"<b>Total Population</b>:\", format(data$total[data$id == input$clickedAreaServed], big.mark = \",\"))\n    } else {\n      txt <- \"\"\n    }\n    return(txt)\n  })\n\n  observe({\n    session$sendCustomMessage(type = \"areaServedMonitorUpdate\", areaServedMonitor())\n  })\n\n  observe({\n    site <- input$correlations\n    parameter <- isolate(input$expParam)\n    sites <- isolate(selectedSites()$Key)\n    if(!is.null(parameter)) {\n      sql <- paste0(\"SELECT site1, site2, cor, dif, dis FROM correlation WHERE parameter = \", parameter, \" AND site1 IN (\", paste0(sites, collapse = \", \"), \")  AND site2 IN (\", paste0(sites, collapse = \", \"), \") AND (site1 = \", site, \" OR site2 = \", site, \")\")\n      q <- dbGetQuery(db, sql)\n      q$site1 <- sapply(seq(nrow(q)), function(i) {\n        if(q$site1[i] == site) {\n          return(q$site2[i])\n        } else {\n          return(q$site1[i])\n        }\n      })\n      q <- q[, c(\"site1\", \"cor\")]\n      colnames(q) <- c(\"site\", \"cor\")\n      session$sendCustomMessage(type = \"showMapCorrelations\", q)\n    }\n  })\n\n  output$agePlot <- renderPlot({\n    \n    input$clickedAreaServed\n\n    if(!is.null(input$clickedAreaServed)) {\n      p <- params$Parameter_Desc[params$Parameter_Code == input$expParam]\n      title <- paste0(p, \" - Area Served by \", areaServedMonitor())\n      gg <- agePyramid(polygons()@data, input$clickedAreaServed) + ggtitle(title)\n      suppressWarnings(print(gg))\n      \n    }\n  }, width = 788, height = 900)\n\n  output$naaqsProb <- renderText({\n\n    if(!is.null(input$expParam)) {\n      data <- as.data.frame(polygons())\n      data <- data[data$id == input$clickedAreaServed, ]\n      prob <- \"Not Available\"\n      if(input$expParam == 44201) {\n        if(input$ozoneNAAQS == \"65ppb\") {\n          prob <- data$ozone_prob_65[1]\n        } else if(input$ozoneNAAQS == \"70ppb\") {\n          prob <- data$ozone_prob_70[1]\n        } else {\n          prob <- data$ozone_prob_75[1]\n        }\n        prob <- paste0(\"<b>Maximum Probability</b>: \", prob)\n      } else if(input$expParam %in% c(88101, 88502)) {\n        prob <- paste0(\"<b>Maximum Probability</b>: \", data$pm_prob_35[1])\n      }\n      return(prob)\n    }\n  })\n\n  output$racePlot <- renderPlot({\n    \n    input$clickedAreaServed\n    \n    if(!is.null(input$clickedAreaServed)) {\n      \n      data <- as.data.frame(polygons())\n      data <- data[data$id == input$clickedAreaServed,  c(\"white\", \"black\", \"native\", \"asian\", \"islander\", \"other\", \"multiple\")]\n      \n      data <- data.frame(label = c(\"White\", \"African American\", \"Native American\", \"Asian\", \"Native Hawaiian/Pacific Islander\", \"Other\", \"Two or More\"),\n                        count = unlist(data))\n            \n      title <- paste0(\"Area Served by \", areaServedMonitor())\n      \n      plt <- ggplot(data, aes(x = label, y = count)) + theme_bw(base_size = 16) + \n        geom_bar(stat = \"identity\", fill = \"turquoise3\" ) +\n        labs(x = \"Race\", y = \"Population\") + \n        theme(axis.text.x = element_text(angle = 20, hjust = 1)) + ggtitle(title)  \n      \n      plt\n      \n    }\n    \n  }, width = 788, height = 900)\n\n  trendChart <- observe({\n\n    site <- input$popupID\n    param <- input$expParam\n    \n    if(!is.null(site) && !is.null(param)) {\n      \n      dv <- dbGetQuery(db, paste0(\"SELECT dv.*, crit_lu.NAME, naaqs.STANDARD, naaqs.UNITS FROM dv JOIN crit_lu ON dv.POLLUTANT = crit_lu.CODE JOIN naaqs ON dv.DURATION = naaqs.DURATION AND dv.POLLUTANT = naaqs.POLLUTANT WHERE crit_lu.PARAMETER = \", param, \" AND dv.Key = \", site))\n      \n      if(nrow(dv) > 0) {\n  \n        values$trendChart <- paste0(\"images/temp/trend\", as.integer(runif(1,1,1000000)), \".png\")\n        \n        trendChart <- plotPNG(function() {\n        \n          pol <- dv$NAME[1]\n          site <- sprintf(\"%02i-%03i-%04i\", dv$STATE_CODE, dv$COUNTY_CODE, dv$SITE_ID)[1]\n          units <- dv$UNITS[1]\n          \n          dv <- dv[, c(\"DURATION\", \"STANDARD\", \"DV_2004\", \"DV_2005\", \"DV_2006\", \"DV_2007\", \"DV_2008\", \"DV_2009\", \"DV_2010\", \"DV_2011\", \"DV_2012\", \"DV_2013\")] \n          dv <- melt(dv)\n          \n          std <- dv[dv$variable == \"STANDARD\", c(\"DURATION\", \"value\")]\n          colnames(std) <- c(\"DURATION\", \"STANDARD\")\n          dv <- dv[dv$variable != \"STANDARD\", ]\n          colnames(dv) <- c(\"DURATION\", \"LABEL\", \"DV\")\n          dv <- merge(dv, std, by = \"DURATION\")\n          dv$LABEL <- as.numeric(substr(as.character(dv$LABEL), 4, 7))\n          dv$SNAME <- paste(dv$DURATION, \"Standard\")\n          dv$DURATION <- paste(dv$DURATION, \"Design Value\")\n          \n          cbPalette <- c(\"#E69F00\", \"#D55E00\", \"#56B4E9\", \"#0072B2\")\n          \n          title <- paste0(\"Design Value Trends: \", pol, \" at \", site)\n          \n          plt <- ggplot(dv, aes(x = LABEL, y = DV, colour = DURATION, ymin = 0)) + labs(colour = \"\") +\n            geom_hline(aes(yintercept = STANDARD, colour = SNAME), show_guide = TRUE, size = 1.25) +\n            geom_line(size = 1.5) +\n            geom_point(size = 4) +\n            labs(x = \"Year\", y = paste0(\"Design Value (\", units, \")\")) + \n            theme_bw(base_size = 16) + theme(legend.position=\"bottom\") + \n            scale_colour_manual(values=cbPalette) +\n            ggtitle(title)\n          \n          print(plt)\n        \n        }, width = 900, height = 450, filename = paste0(\"www/\", values$trendChart))\n          \n        session$sendCustomMessage(type = \"updateTrendChart\", values$trendChart)\n        \n      }\n    \n    }\n    \n  })\n\n  output$corplot <- renderPlot({\n    \n    input$cormatButton\n    parameter <- isolate(input$expParam)\n    if(is.null(parameter)) {parameter = -1}\n    sites <- isolate(selectedSites()$Key)\n        \n    if(parameter %in% c(44201, 88101, 88502) & length(sites) > 1) {\n      return(cormat(db, sites, parameter))      \n    }\n  \n  }, width = 1800, height = 1350)\n\n  cormatData <- reactive({\n    if(input$expParam != \"-1\" && !is.null(selectedSites())) {\n      parameter <- isolate(input$expParam)\n      sites <- isolate(selectedSites()$Key)\n      sql <- paste0(\"SELECT site1, site2, cor, dif, dis FROM correlation WHERE parameter = \", parameter, \" AND site1 IN (\", paste0(sites, collapse = \", \"), \")  AND site2 IN (\", paste0(sites, collapse = \", \"), \")\")\n      q <- dbGetQuery(db, sql)\n      sites <- unique(c(q$site1, q$site2))\n      sites <- dbGetQuery(db, paste0(\"SELECT Key, State_Code, County_Code, Site_ID FROM sites WHERE Key IN (\", paste(sites, collapse = \", \"), \")\"))\n      sites$ID <- sprintf(\"%02i-%03i-%04i\", sites$State_Code, sites$County_Code, sites$Site_ID)\n      q$site1 <- sapply(q$site1, function(s) sites$ID[sites$Key == s])\n      q$site2 <- sapply(q$site2, function(s) sites$ID[sites$Key == s])\n      colnames(q) <- c(\"Site 1\", \"Site 2\", \"Correlation\", \"Rel. Dif\", \"Distance (km)\")  \n      return(q)\n    }\n  })\n\n  output$downloadData <- downloadHandler(filename = function() {paste0(\"netassess-\", input$expParam, \"-\", Sys.Date(), \".zip\")},\n                                         content = function(file) {\n                                            files <- c()\n                                            td <- tempdir()\n                                            setwd(tempdir())\n\n                                            # Sites Data\n                                            fn <- suppressWarnings(normalizePath(paste(td, \"sites.csv\", sep = \"/\")))\n                                            d <- sites()[sites()$Key %in% input$selectedSites, ]\n                                            write.csv(d, file = fn)\n                                            files <- c(files, fn)\n                                            \n                                            # Correlation Data\n                                            fn <- suppressWarnings(normalizePath(paste(td, \"correlation.csv\", sep = \"/\")))\n                                            write.csv(cormatData(), file = fn)\n                                            files <- c(files, fn)\n                                            \n                                            # Area Served Data (if available)\n                                            if(!is.null(polygons())) {\n                                              fn <- suppressWarnings(normalizePath(paste(td, \"areaServed.csv\", sep = \"/\")))\n                                              d <- polygons()@data\n                                              d$area <- unlist(d$area)\n                                              write.csv(d, file = fn)\n                                              files <- c(files, fn)\n                                            }\n                                            \n                                            zip(file, files, flags=\"\")   \n                                         \n                                            if (file.exists(paste0(file, \".zip\")))\n                                              file.rename(paste0(file, \".zip\"), file)\n                                            \n                                            \n                                         },\n                                         contentType = \"application/zip\")\n\n  output$downloadCorMat <- downloadHandler(filename = function() {paste0(\"cormat-\", input$expParam, \"-\", Sys.Date(), \".csv\")},\n                                           content = function(file) {\n                                             q <- cormatData()\n                                             write.csv(q, file, row.names = FALSE)\n                                           })\n\n})\n\n",
    "created" : 1421337923673.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1758261210",
    "id" : "50DDDDA",
    "lastKnownWriteTime" : 1421337189,
    "path" : "C:/R/NetAssessApp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}