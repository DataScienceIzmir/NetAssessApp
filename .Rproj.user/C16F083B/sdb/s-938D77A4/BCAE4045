{
    "contents" : "/* Input Bindings for custom shiny inputs */\nnetAssess.shinyBindings = {};\n\nnetAssess.shinyBindings.correlations = new Shiny.InputBinding();\n  $.extend(netAssess.shinyBindings.correlations, {\n    find: function(scope) {\n      return $(scope).find(\"#correlations\");\n    },\n    getValue: function(el) {\n      return $(el).data(\"site\")\n    },\n    subscribe: function(el, callback) {\n      $(el).on(\"viewCor\", function(e, trigger) {\n        $(el).data(\"site\", trigger.feature.properties.key);\n        callback()\n      })\n    }\n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.correlations);\n\nnetAssess.shinyBindings.popupID = new Shiny.InputBinding();\n  $.extend(netAssess.shinyBindings.popupID, {\n    find: function(scope) {\n      return $(scope).find(\"#popupID\")\n    },\n    getValue: function(el) {\n      return $(el).data(\"key\")\n    },\n    subscribe: function(el, callback) {\n      netAssess.map.on(\"popupopen\", function(e) {\n        var key = e.popup._source.feature.properties.key;\n        $(el).data(\"key\", key);\n        callback();\n      })\n    }\n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.popupID);\n  \n  // Input that informs shiny about the new monitoring locations that have been \n  // added\nnetAssess.shinyBindings.newSites = new Shiny.InputBinding();\n  $.extend(netAssess.shinyBindings.newSites, {\n    find: function(scope) {\n      return $(scope).find(\"#newSites\")\n    },\n    getValue: function(el) {\n      if(newSites != null) {\n        var new_sites = [];\n        netAssess.layerGroups.newSites.eachLayer(function(layer) {\n          \n          new_sites.push({lat: layer.feature.geometry.coordinates[1],\n                          lng: layer.feature.geometry.coordinates[0],\n                          name: layer.feature.properties.Name,\n                          params: layer.feature.properties.Params,\n                          visible: layer.feature.properties.visible,\n                          selected: layer.feature.properties.selected,\n                          key: layer.feature.properties.key});\n                          \n        })\n        return {data: new_sites};\n      }\n    },\n    subscribe: function(el, callback) {\n      $(\"#map\").on(\"newSiteUpdate\", callback);\n    },\n    unsubscribe: function(el) {\n      $(\"#map\").off(\"newSiteUpdate\");\n    }\n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.newSites);\n\n  // Input that informs shiny about the monitoring locations that have been \n  // selected.\nnetAssess.shinyBindings.selectedSites = new Shiny.InputBinding()\n  $.extend(netAssess.shinyBindings.selectedSites, {\n    find: function(scope) {\n      return $(scope).find(\"#selectedSites\")\n    },\n    getValue: function(el) {\n      if(netAssess.layerGroups.sites != null) {\n        var selSites = [];\n        netAssess.layerGroups.sites.eachLayer(function(layer) {\n            if(layer.feature.properties.selected & layer.feature.properties.visible) {\n                selSites.push(layer.feature.properties.key)\n            }\n        })\n        return selSites;\n      }\n    },\n    subscribe: function(el, callback) {\n      $(\"#map\").on(\"siteSelection\", callback);\n    },\n    unsubscribe: function(el) {\n      $(\"#map\").off(\"siteSelection\");\n    }  \n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.selectedSites);\n  \n  // Input that informs shiny about currently visible monitoring locations. This\n  // really complicated things but was necessary to allow users to remove a \n  // monitor within an area of interest that they didn't want to affect analysis\nnetAssess.shinyBindings.visibleSites = new Shiny.InputBinding();\n  $.extend(netAssess.shinyBindings.visibleSites, {\n    find: function(scope) {\n      return $(scope).find(\"#visibleSites\");\n    },\n    getValue: function(el) {\n      var vs = [];\n      netAssess.layerGroups.sites.eachLayer(function(layer) {\n        if(layer.feature.properties.visible) vs.push(layer.feature.properties.key)\n      })\n      return vs;\n    },\n    subscribe: function(el, callback) {\n      $(\"#map\").on(\"siteUpdate\", callback);\n    },\n    unsubscribe: function(el) {\n      $(\"#map\").off(\"siteUpdate\");\n    }\n  });\n  Shiny.inputBindings.register(netAssess.shinyBindings.visibleSites);\n  \n  // Input that updates when an area served polygon is clicked. Allows shiny to\n  // provide demographic and geographic information about that area, including\n  // the age pyramid plot.\nnetAssess.shinyBindings.clickedAreaServed = new Shiny.InputBinding()\n  $.extend(netAssess.shinyBindings.clickedAreaServed, {\n    find: function(scope) {\n      return $(scope).find(\"#clickedAreaServed\");\n    },\n    getValue: function(el) {\n      return $(el).data(\"clicked\");\n    },\n    subscribe: function(el, callback) {\n      $(\"#map\").on(\"areaClick\", callback);\n    },\n    unsubscribe: function(el) {\n      $(\"#map\").off(\"areaClick\");\n    }\n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.clickedAreaServed);\n  \n  // Input that updates when a monitoring location is selected. This was used\n  // when the demographic/geographic data was handled differently. Still here\n  // in case I need it later.\nnetAssess.shinyBindings.monSelect = new Shiny.InputBinding();\n  $.extend(netAssess.shinyBindings.monSelect, {\n    find: function(scope) {\n      return $(scope).find(\"#monitorSelect\")\n    },\n    getValue: function(el) {\n      return $(el).data(\"monitor\");\n    },\n    setValue: function(el, value) {\n      $(el).data(\"monitor\", value)\n    },\n    subscribe: function(el, callback) {\n      $(\"#map\").on(\"monitorSelect\", function(el) {\n        callback();\n      })\n    },\n    unsubscribe: function(el) {\n      $(el).off(\"click.netassess\")\n    }\n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.monSelect);\n\n// Binding to let shiny know what the currently selected area of interest is. \n// Used for clipping area served polygons.\nnetAssess.shinyBindings.areaOfInterest = new Shiny.InputBinding();\n  $.extend(netAssess.shinyBindings.areaOfInterest, {\n    find: function(scope) {\n      return $(scope).find(\"#areaOfInterest\")\n    },\n    getValue: function(el) {\n      return $(el).data(\"aoi\")\n    },\n    subscribe: function(el, callback) {\n      $(\"#map\").on(\"aoiChange\", function(el) {\n        callback();\n      })\n    },\n    unsubscribe: function(el) {\n      $(\"#map\").off(\"aoiChange\");\n    }\n  })\n  Shiny.inputBindings.register(netAssess.shinyBindings.areaOfInterest);\n\n/* Custom Message Handlers */\n\nShiny.addCustomMessageHandler(\"displayPredefinedArea\", netAssess.setPredefinedArea);\n\nShiny.addCustomMessageHandler(\"updateAreaServed\", netAssess.updateAreaServed)\n\nShiny.addCustomMessageHandler(\"updateVisibleMonitors\", netAssess.updateVisibleMonitors)\n\nShiny.addCustomMessageHandler(\"areaServedMonitorUpdate\", function(data) {\n  netAssess.floaters.areaServed.updateTitle(\"Area Served - \" + data)  \n})\n\nShiny.addCustomMessageHandler(\"updateTrendChart\", function(data) {\n  $(\".popup-trend\").find(\"img\").attr(\"src\", data)\n})\n\nShiny.addCustomMessageHandler(\"triggerEvent\", function(data) {\n  $(data.target).trigger(data.event);\n})\n\nShiny.addCustomMessageHandler(\"showMapCorrelations\", function(data) {\n  netAssess.layerGroups.correlations.clearLayers();\n  netAssess.layerGroups.sites.eachLayer(function(layer) {\n    for(var i = 0; i < layer.feature.properties.key.length; i++) {\n      var index = data.site.indexOf(layer.feature.properties.key[i]);\n      if(index != -1) {\n        var cor = data.cor[index];\n        var ll = L.latLng(layer.feature.geometry.coordinates[1], layer.feature.geometry.coordinates[0]);\n        var col = netAssess.corColor(cor);\n        netAssess.layerGroups.correlations.addLayer(L.circleMarker(ll, \n                                                    {color: col.border,\n                                                    weight: 1.5,\n                                                    fillColor: col.fill, \n                                                    radius: 10,\n                                                    fillOpacity: 0.5}));\n      }\n    }\n  })\n})",
    "created" : 1421355286495.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3884797805",
    "id" : "BCAE4045",
    "lastKnownWriteTime" : 1421337190,
    "path" : "C:/R/NetAssessApp/www/js/netassess-shiny.js",
    "project_path" : "www/js/netassess-shiny.js",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "js"
}