{
    "contents" : "library(shiny)\nlibrary(sp)\n\nshinyServer(function(input, output, session) {\n  \n  updateSelectInput(session, \"expParam\", choices = params.list)\n  \n  # This stores a makeshift bounding box to subset the monitors on\n  bbox <- reactive({\n\n    north = input$mapBounds$bounds[[2]]$lat\n    east = input$mapBounds$bounds[[2]]$lng\n    south = input$mapBounds$bounds[[1]]$lat\n    west = input$mapBounds$bounds[[1]]$lng\n    vert = min((north - south) / 2, 4)\n    horz = min(abs(west - east) / 2, 4)\n    \n    north = north + vert\n    east = east + horz\n    south = south - vert\n    west = west - horz\n    \n    list(north = north, east = east, south = south, west = west)\n    \n  })\n  \n  localTracts <- reactive({\n    subset(tracts, lat > bbox()$south & lat < bbox()$north & lng > bbox()$west & lng < bbox()$east)\n  })\n  \n  sites <- reactive({\n    if(!is.null(input$expParam)) {\n      if(input$expParam != -1) {\n        site.list <- dbGetQuery(db, paste0(\"SELECT sites.Key, sites.Latitude, sites.Longitude FROM sites JOIN monitors ON sites.Key =  monitors.Site_Key WHERE monitors.PARAMETER = \", input$expParam))\n        site.list <- unique(site.list[site.list$Latitude <= bbox()$north & \n                                      site.list$Latitude >= bbox()$south &\n                                      site.list$Longitude >= bbox()$west &\n                                      site.list$Longitude <= bbox()$east, ])\n        return(site.list)\n      } else {return(NULL)}\n    } else {return(NULL)}\n  })\n  \n  polygons <- reactive({\n    if(!is.null(sites())) {\n      if(input$expParam %in% aSapp & nrow(sites()) <= 400 & nrow(sites()) >= 2) {\n        v <- voronoi(sites()$Key, sites()$Latitude, sites()$Longitude, usborder)\n        ov <- over(localTracts(), v)\n        t <- cbind(localTracts()@data, ov)\n        t <- t[!is.na(t$id), ]\n        d <- aggregate(t[, 3:47], by = list(as.character(t$id)), FUN = sum, na.rm = TRUE)\n        proj4string(v) <- CRS(\"+proj=longlat +ellps=WGS84\")\n        area <- areaPolygons(v, CRS(\"+init=epsg:2163\"))\n        v@data <- merge(v@data, d, by.x=\"id\", by.y = \"Group.1\", all.x = TRUE, all.y = FALSE)\n        v@data <- cbind(v@data, area = area)\n        ids <- sapply(v@data$id, function(i) {strsplit(i, \" \")[[1]][1]})\n        v@data$id <- ids\n      } else {v <- NULL}\n    } else {v <- NULL}\n    return(v)\n  })\n  \n  observe({\n    if(!is.null(sites())) {\n      ss <- Sys.time()\n      keys <- unique(sites()$Key)\n      session$sendCustomMessage(type=\"showMonitors\", keys)\n    }\n  })\n  \n  observe({\n    if(!is.null(polygons())) {\n      v <- lapply(polygons()@polygons, function(p) {\n        lapply(p@Polygons, function(pp) {\n          coords <- pp@coords\n          apply(coords, 1, function(r) {\n            list(lat = r[[2]], lng = r[[1]])\n          })\n        })\n      })\n      session$sendCustomMessage(type = \"showArea\", v)\n    }\n  })\n  \n  # Observer to update predefined area select input based on Area Type\n  observe({\n    \n    if(!is.null(input$areaSelect)) {\n      \n      if(input$areaSelect==\"State\") {\n        choices = state.list\n      } else if(input$areaSelect == \"CBSA\") {\n        choices = cbsa.list\n      } else if(input$areaSelect == \"CSA\") {\n        choices = csa.list\n      } else {\n        choices = c(\"\")\n      }\n      \n      updateSelectInput(session, \"areaSelectSelect\", choices = choices)\n      \n    }\n    \n  })\n  \n  observe({\n    \n    if(!is.null(input$areaSelectSelect)) {\n      \n      type <- toupper(isolate(input$areaSelect))\n      \n      src <- switch(type, STATE = \"states\", CBSA = \"cbsas\", CSA = \"csas\")\n\n      q <- paste0(\"SELECT GEOMETRY FROM \", src, \" WHERE CODE = '\", input$areaSelectSelect, \"'\")\n\n      coords <- eval(parse(text = dbGetQuery(db, q)[1,1]))\n      \n      session$sendCustomMessage(type=\"displayArea\", list(properties = list(name = \"test\", type = type, id = input$areaSelectSelect), coords = coords))\n      \n    }\n    \n  })\n\n  output$agePlot <- renderPlot({\n    \n    data <- polygons()@data\n    ggplot(data=data,aes(x=as.factor(v),fill=g)) + \n      geom_bar(subset=.(g==\"F\")) + \n      geom_bar(subset=.(g==\"M\"),aes(y=..count..*(-1))) + \n      scale_y_continuous(breaks=seq(-40,40,10),labels=abs(seq(-40,40,10))) + \n      coord_flip()\n    \n  })\n\n})\n\n\n",
    "created" : 1413571264764.000,
    "dirty" : true,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2540761125",
    "id" : "6307B3B9",
    "lastKnownWriteTime" : 1413575472,
    "path" : "C:/R/NetAssessApp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}