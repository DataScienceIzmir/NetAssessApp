{
    "contents" : "library(shiny)\n\nshinyServer(function(input, output, session) {\n  \n#### Functions for controlling parameter selection\n  \n  # Populate the parameter selection dropdown  \n  updateSelectInput(session, \"expParam\", choices = params.list)\n  updateSelectInput(session, \"new_site_parameters\", choices = params.list[2:length(params.list)])\n  \n  # Contains a list of sites based on the currently selected parameter\n  sites <- reactive({\n    if(!is.null(input$expParam)) {\n      if(input$expParam != -1) {\n        site.list <- dbGetQuery(db, paste0(\"SELECT sites.* FROM sites JOIN monitors ON sites.Key =  monitors.Site_Key WHERE monitors.PARAMETER = \", input$expParam))\n        return(site.list)\n      } else {return(NULL)}\n    } else {return(NULL)}\n  })\n  \n  visibleNewSites <- reactive({\n    new_sites <- input$newSites$data\n    if(length(new_sites) > 0) {\n      vns <- data.frame(stringsAsFactors = FALSE)\n      for(i in seq(length(new_sites))) {\n        n <- new_sites[[i]]\n        if(n$visible == TRUE) {\n          vns <- rbind(vns, c(n$lat, n$lng, n$key, n$selected, n$name))\n        }\n      }\n      \n      colnames(vns) <- c(\"Latitude\", \"Longitude\", \"Key\", \"selected\", \"name\")\n      vns$Latitude <- as.numeric(vns$Latitude)\n      vns$Longitude <- as.numeric(vns$Longitude)\n      vns$selected <- as.logical(vns$selected)\n      return(vns)\n    }\n  })\n  \n  selectedNewSites <- reactive({\n    vns <- visibleNewSites()\n    return(vns[vns$selected, ])\n  })\n  \n  visibleSites <- reactive({\n    \n    return(sites()[sites()$Key %in% input$visibleSites, ])\n    \n  })\n\n  # Send a custom message to update visible monitors based on parameter selection\n  observe({\n    if(!is.null(sites())) {\n      keys <- unique(sites()$Key)\n    } else {\n      keys <- list()\n    }\n    session$sendCustomMessage(type=\"updateVisibleMonitors\", keys)\n  })\n\n#### Functions for controlling the Area of Interest Selection\n\n  # Observer to update predefined area select input based on Area Type\n  observe({\n    \n    if(!is.null(input$areaSelect)) {\n      \n      if(input$areaSelect==\"State\") {\n        choices = state.list\n      } else if(input$areaSelect == \"CBSA\") {\n        choices = cbsa.list\n      } else if(input$areaSelect == \"CSA\") {\n        choices = csa.list\n      } else {\n        choices = c(\"\")\n      }\n      \n      updateSelectInput(session, \"areaSelectSelect\", choices = choices)\n      \n    }\n    \n  })\n\n  # Send the geometry for a predefined area selection\n  observe({\n    \n    if(!is.null(input$areaSelectSelect)) {\n      \n      type <- toupper(isolate(input$areaSelect))\n      \n      src <- switch(type, STATE = \"states\", CBSA = \"cbsas\", CSA = \"csas\")\n      \n      q <- paste0(\"SELECT GEOMETRY FROM \", src, \" WHERE CODE = '\", input$areaSelectSelect, \"'\")\n      \n      coords <- eval(parse(text = dbGetQuery(db, q)[1,1]))\n      \n      session$sendCustomMessage(type=\"displayPredefinedArea\", list(properties = list(name = \"test\", type = type, id = input$areaSelectSelect), coords = coords))\n      \n    }\n    \n  })\n\n##### Area Served Functions\n\n  selectedSites <- reactive({\n\n      sites <- sites()\n      if(!is.null(sites)) {\n        ss <- sites[sites$Key %in% input$selectedSites, c(\"Key\", \"Latitude\", \"Longitude\")]\n        if(nrow(ss) == 0) {ss <- NULL}\n      } else {\n        ss <- NULL\n      }\n\n      return(ss)\n    \n  })\n\n  selectedNeighbors <- reactive({\n\n    ss <- selectedSites()\n    ss <<- ss\n    nss <- selectedNewSites()[, c(\"Key\", \"Latitude\", \"Longitude\")]\n    nss <<- nss\n    sss <- isolate(visibleSites()[, c(\"Key\", \"Latitude\", \"Longitude\")])\n    sss <<- sites\n    newsites <- isolate(visibleNewSites()[, c(\"Key\", \"Latitude\", \"Longitude\")])\n    newsites <<- newsites\n    \n    ss <- rbind(ss, nss)\n    sites <- rbind(sss, newsites)\n\n    \n    \n    if(!is.null(ss)) {\n        \n      us.lats <- c(24.4, 49.4)\n      us.lngs <- c(-124.8, -66.9)\n      \n      lats <- range(ss$Latitude)\n      lngs <- range(ss$Longitude)\n      \n      lat.rng <- max(abs(lats[2] - lats[1]), 1)\n      lng.rng <- max(abs(lngs[2] - lngs[1]), 1)\n          \n      gtG <- FALSE\n      \n      while(!gtG) {\n        \n        lats.test <- c(lats[1] - lat.rng, lats[2] + lat.rng)\n        lngs.test <- c(lngs[1] - lng.rng, lngs[2] + lng.rng)\n        \n        # Test if us border has been reach in any cardinal direction\n        bounds <- list(north = lats.test[2] >= us.lats[2],\n                       south = lats.test[1] <= us.lats[1],\n                       east =  lngs.test[2] >= us.lngs[2],\n                       west =  lngs.test[1] <= us.lngs[1])\n\n        neighbors <- unique(sites[sites$Latitude >= lats.test[1] & \n                                  sites$Latitude <= lats.test[2] & \n                                  sites$Longitude >= lngs.test[1] & \n                                  sites$Longitude <= lngs.test[2], ])\n\n        if(!bounds$north) {\n          n <- neighbors[neighbors$Latitude > lats[2], ]\n          bounds$north <- (sum(n$Longitude > lngs[2]) > 0 &\n                           sum(n$Longitude < lngs[1]) > 0 &\n                           sum(n$Longitude < lngs[2] & n$Longitude > lngs[1]) > 0)\n        }\n        if(!bounds$south) {\n          n <- neighbors[neighbors$Latitude < lats[1], ]\n          bounds$south <- (sum(n$Longitude > lngs[2]) > 0 &\n                             sum(n$Longitude < lngs[1]) > 0 &\n                             sum(n$Longitude < lngs[2] & n$Longitude > lngs[1]) > 0)\n        }\n        if(!bounds$east) {\n          n <- neighbors[neighbors$Longitude > lngs[2], ]\n          bounds$east <- (sum(n$Latitude > lats[2]) > 0 &\n                             sum(n$Latitude < lats[1]) > 0 &\n                             sum(n$Latitude < lats[2] & n$Latitude > lats[1]) > 0)\n        }\n        if(!bounds$west) {\n          n <- neighbors[neighbors$Longitude < lngs[1], ]\n          bounds$west <- (sum(n$Latitude > lats[2]) > 0 &\n                            sum(n$Latitude < lats[1]) > 0 &\n                            sum(n$Latitude < lats[2] & n$Latitude > lats[1]) > 0)\n        }\n        \n        gtG <- bounds$north & bounds$south & bounds$east & bounds$west\n              \n        lat.rng <- lat.rng * 2\n        lng.rng <- lng.rng * 2\n        \n      }\n      \n      neighbors <- neighbors[!duplicated(neighbors[, c(\"Latitude\", \"Longitude\")]), ]\n      v <- deldir(neighbors$Longitude, neighbors$Latitude)\n      x <- v$delsgs\n      x$ind1 <- neighbors$Key[x$ind1]\n      x$ind2 <- neighbors$Key[x$ind2]\n      x <- x[x$ind1 %in% ss$Key | x$ind2 %in% ss$Key, ]\n      x <- unique(c(x$ind1, x$ind2))\n    \n      return(neighbors[neighbors$Key %in% x, ])\n    \n    }\n    \n  })\n\n  polygons <- reactive({\n    if(input$areaServedCalcButton > 0) {\n      ss <- isolate(selectedSites())\n      nss <- selectedNewSites()[, c(\"Key\", \"Latitude\", \"Longitude\")]\n      ss <- rbind(ss, nss)\n      \n      sn <- isolate(selectedNeighbors())\n      \n      if(!is.null(ss)) {\n        if(nrow(ss) <= 400 & nrow(sn) >= 2) {\n          if(input$areaServedClipping == \"none\") {\n            v <- voronoi(sn$Key, sn$Latitude, sn$Longitude)\n          } else {\n            if(input$areaServedClipping == \"border\") {\n              b <- usborder\n            } else {\n              b <- areaOfInterest()\n            }\n\n            v <- voronoi(sn$Key, sn$Latitude, sn$Longitude, b)\n          }\n          v <- subset(v, id %in% ss$Key)\n          ov <- over(tracts, v)\n          t <- cbind(tracts@data, ov)\n          t <- t[!is.na(t$id), ]\n          d <- aggregate(t[, 3:47], by = list(as.character(t$id)), FUN = sum, na.rm = TRUE)\n          proj4string(v) <- CRS(\"+proj=longlat +ellps=WGS84\")\n          area <- areaPolygons(v, CRS(\"+init=epsg:2163\"))        \n          v@data <- merge(v@data, d, by.x=\"id\", by.y = \"Group.1\", all.x = TRUE, all.y = FALSE)\n          v@data <- merge(v@data, area, by = \"id\", all.x = TRUE, all.y = FALSE)\n          #ids <- sapply(v@data$id, function(i) {strsplit(i, \" \")[[1]][1]})\n          #v@data$id <- ids\n        } else {\n          v <- NULL\n        }\n      } else {\n        v <- NULL\n      }\n      return(v)\n    }\n  })\n\n  observe({\n    if(!is.null(polygons())) {\n      polygons <- polygons()\n      v <- lapply(seq(nrow(polygons)), function(i) {\n        list(id = unlist(strsplit(polygons@polygons[[i]]@ID, \" \"))[1], \n             coords = lapply(polygons@polygons[[i]]@Polygons, function(pp) {\n                coords <- pp@coords\n                apply(coords, 1, function(r) {\n                  list(lat = r[[2]], lng = r[[1]])\n                })\n              })\n        )\n      })\n      session$sendCustomMessage(type = \"updateAreaServed\", v)\n    }\n  })\n\n  areaServedMonitor <- reactive({\n    monkey <- as.numeric(input$clickedAreaServed)\n    if(length(monkey) > 0) {\n      if(monkey < 90000) {\n        sites <- isolate(sites())\n        mon <- sites[sites$Key %in% monkey, ]\n        mon <- sprintf(\"%02i-%03i-%04i\", mon$State_Code, mon$County_Code, mon$Site_ID)\n      } else {\n        sites <- isolate(visibleNewSites())\n        mon <- paste(sites[sites$Key %in% monkey, \"name\"], \"(New Site)\")\n      }\n      return(mon)\n    }\n  })\n\n  output$areaServedMonitor <- renderText({\n    areaServedMonitor()\n  })\n\n  areaOfInterest <- reactive({\n    \n    aoi <- input$areaOfInterest\n    aoi <- aoi[[1]]\n    if(is.null(names(aoi[[1]]))) {\n      polygons <- lapply(aoi, function(p) {\n        m <- matrix(as.numeric(do.call(rbind, p)), ncol = 2)\n        m <- rbind(m, m[1, ])\n        m <- m[, c(2, 1)]\n        Polygon(coords = m, hole = FALSE)\n      })\n    } else {\n      m <- matrix(as.numeric(do.call(rbind, aoi)), ncol = 2)\n      m <- rbind(m, m[1, ])\n      m <- m[, c(2, 1)]\n      polygons <- list(Polygon(coords = m, hole = FALSE))\n    }\n    polygons <- SpatialPolygons(list(Polygons(polygons, \"aoi\")))\n    return(polygons)\n    \n  })\n\n  output$areaServed <- renderText({\n    input$clickedAreaServed\n    polygons <- polygons()\n    if(!is.null(polygons)) {\n      data <- polygons@data\n      txt <- paste(format(data$area[data$id == input$clickedAreaServed], big.mark = \",\"), \"square km\")\n    } else {\n      txt <- \"\"\n    }\n    return(txt)\n  })\n\n  output$totalPopServed <- renderText({\n    input$clickedAreaServed\n    polygons <- polygons()\n    if(!is.null(polygons)) {\n      data <- polygons@data\n      txt <- paste(format(data$total[data$id == input$clickedAreaServed], big.mark = \",\"), \"Total Population\")\n    } else {\n      txt <- \"\"\n    }\n    return(txt)\n  })\n\n  output$agePlot <- renderPlot({\n    \n    input$clickedAreaServed\n\n    if(!is.null(input$clickedAreaServed)) {\n      \n      gg <- agePyramid(polygons()@data, input$clickedAreaServed)\n      suppressWarnings(print(gg))\n      \n    }\n  }, width = 400, height = 450)\n\n  output$corplot <- renderPlot({\n    \n    input$cormatButton\n    parameter <- isolate(input$expParam)\n    if(is.null(parameter)) {parameter = -1}\n    sites <- isolate(selectedSites()$Key)\n        \n    if(parameter %in% c(44201, 88101, 88502) & length(sites) > 1) {\n      return(cormat(db, sites, parameter))      \n    \n    }\n  \n  }, width = 1200, height = 900)\n\n  output$downloadAgePlot <- downloadHandler(filename = function() {paste(\"AgePlot_\", areaServedMonitor(), \"_\", input$expParam, \".png\")},\n                                            content = function(file) {\n                                              device <- function(..., width, height) grDevices::png(..., width = 6, height = 8, res = 150, units = \"in\")\n                                              ggsave(file, plot = agePyramid(polygons()@data, input$clickedAreaServed) + ggtitle(bquote(atop(\"Age Pyramid\", atop(.(paste0(\"Site ID: \", areaServedMonitor())), .(paste0(\"Parameter Code: \", input$expParam)))))), device = device)\n                                            })\n\n  output$downloadCorMat <- downloadHandler(filename = function() {paste(\"CorMat_\", input$expParam, \"_\", as.integer(runif(1, 1, 999999)),\".png\")},\n                                           content = function(file) {\n                                             parameter <- isolate(input$expParam)\n                                             if(is.null(parameter)) {parameter = -1}\n                                             sites <- isolate(selectedSites()$Key)\n                                             if(parameter %in% c(44201, 88101, 88502) & length(sites) > 1) {\n                                               png(file, 1200, 900)\n                                               cormat(db, sites, parameter)      \n                                               dev.off()\n                                             }\n                                           })\n\n  output$downloadData <- downloadHandler(filename = function() {paste0(\"netassess-\", Sys.Date(), \".csv\")},\n                                         content = function(file) {\n                                           d <- polygons()@data\n                                           d$area <- unlist(d$area)\n                                           d <- merge(d, sites(), by.x = \"id\", by.y = \"Key\", all.x = TRUE, all.y = FALSE)\n                                           d <- d[, c(\"State_Code\", \"County_Code\", \"Site_ID\", \"Latitude\", \"Longitude\", \"Street_Address\", \"area\", \"total\", \"Count\", \"Crit_Count\", \"HAP_Count\", \"Met_Count\")]\n                                           colnames(d) <- c(\"State Code\", \"County Code\", \"Site ID\", \"Latitude\", \"Longitude\", \"Street Addres\", \"Area (km^2)\", \"Total Population\", \"Total Parameters Monitored\", \"Criteria Monitored\", \"HAPS Monitored\", \"Meteorology Monitored\")\n                                           write.csv(d, file, row.names = FALSE)\n                                         })\n\n\n})\n\n",
    "created" : 1417699489250.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3621017416",
    "id" : "110AC42F",
    "lastKnownWriteTime" : 1417453646,
    "path" : "C:/R/NetAssessApp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}